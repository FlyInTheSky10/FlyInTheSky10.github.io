{"posts":[{"title":"「Loj 2312」「HAOI2017」供给侧改革 (Trie + 类似数论分块)","text":"Loj 2312 题意：给出一个 n​n​n​ 位随机 01​01​01​ 串，定义 data(l,r)=max⁡(LCP(Sufi,Sufj)∣i≠j,l≤i,j≤r)​\\text{data}(l,r)=\\max(\\text{LCP}(\\text{Suf}_i,\\text{Suf}_j)|i≠j,l≤i,j≤r)​data(l,r)=max(LCP(Sufi​,Sufj​)∣i=j,l≤i,j≤r)​ 。 给出 m​m​m​ 个询问 [l,r]​[l,r]​[l,r]​ ，求 ∑i=lr−1data(i,r)\\sum\\limits_{i=l}^{r-1}\\text{data}(i,r) i=l∑r−1​data(i,r) 题目说随机生成，那么估计LCP相同的概率为(12)len⋅Cr−l+12({1\\over 2})^{len} \\cdot C^{2}_{r-l+1}(21​)len⋅Cr−l+12​，在取404040时，这个几率已经很小，我们直接对于每个后缀存前404040个字符即可。考虑依次加入每个位置的后缀 我们发现对于一个区间[l,r][l,r][l,r]的答案，一定比[l+1,r],[l+2,r],…,[r−1,r][l+1,r], [l+2,r], \\dots , [r-1,r][l+1,r],[l+2,r],…,[r−1,r]答案更大，因为他们是包含关系 那么我们可以运用这个单调性，还能发现答案是一块一块的，我们联想到数论分块的思想。 设pos(i,j)pos(i,j)pos(i,j)为[1,i][1,i][1,i]中后缀∃LCP=j\\exists \\text{LCP}=j∃LCP=j的最大位置。 那么求答案我们分成一块一块地求，具体看代码注释。 知识点： 1、单调性运用 (类似品酒大会从后往前求答案) 2、离线思想 (按某元素排序) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;cstdio&gt; #include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;string&gt;#define ms(i, j) memset(i, j, sizeof i)#define LL long long#define db double#define fir first#define sec second#define mp make_pairusing namespace std;namespace flyinthesky { const int MAXN = 100000 + 1; struct qry { int l, r, id; bool operator &lt; (const qry &amp;rhs) const { return r == rhs.r ? l &lt; rhs.l : r &lt; rhs.r; } } xw[MAXN]; int n, Q, sz, ch[MAXN * 40][2], maxd[MAXN * 40], lst[MAXN * 40], pos[MAXN][55]; // maxd_i i \\in [0,40]：存在 LCP 长度为 i 的最大位置 // lst_i： 访问该节点的最后子串(用于求maxd) // pos：如上述 char s[MAXN]; LL ans[MAXN]; void insert(int l, int r) { int now = 0, p = 1; for (int i = l; i &lt;= r; ++i, ++p) { int c = s[i] - '0'; if (!ch[now][c]) ch[now][c] = ++sz; now = ch[now][c]; maxd[p] = max(maxd[p], lst[now]); // 更新 lst[now] = l; // 更新当前节点的信息 } } void clean() { ms(maxd, 0), ms(lst, 0), ms(pos, 0), ms(ch, 0), sz = 0; } int solve() { clean(); cin &gt;&gt; n &gt;&gt; Q; scanf(&quot;%s&quot;, s + 1); for (int i = 1; i &lt;= Q; ++i) scanf(&quot;%d%d&quot;, &amp;xw[i].l, &amp;xw[i].r), xw[i].id = i; sort(xw + 1, xw + 1 + Q); for (int i = 1; i &lt;= n; ++i) { // 求 pos insert(i, min(i + 40, n)); for (int j = 1; j &lt;= 40; ++j) pos[i][j] = maxd[j]; pos[i][0] = i - 1; } int T = 1; for (int i = 1; i &lt;= n; ++i) { // 枚举 r (其实这里求出来 pos 就不用离线的) while (T &lt;= Q &amp;&amp; xw[T].r == i) { int lst = 0; for (int j = 1; j &lt;= 40; ++j) { // 扩展 LCP if (pos[i][j]) { if (pos[i][j] &lt; xw[T].l) break ; // 已经不存在在区间 [l, r] 的更长 LCP else ans[xw[T].id] += (pos[i][lst] - pos[i][j]) * lst, lst = j; // 加上这一块的答案，更新端点值 } } ans[xw[T].id] += (pos[i][lst] - xw[T].l + 1) * lst; // 加上最后一块答案 ++T; } } for (int i = 1; i &lt;= Q; ++i) printf(&quot;%lld\\n&quot;, ans[i]); return 0; }}int main() { flyinthesky::solve(); return 0;}","link":"/loj2312/"},{"title":"「新的博客，新的开始」","text":"新的博客，新的开始 — 继续记载所学所言 —","link":"/restart/"},{"title":"xv6 系统简单源码分析","text":"xv6 是一个教学操作系统，它是由 MIT 的 6.S081 课程开发的教学操作系统。xv6基于早期的Unix操作系统（Version 6 Unix）的设计思想，并在其基础上进行了简化和修改。xv6 的设计简单且易于理解，代码量相对较小，只有一万多行。初学者可以更容易地阅读和理解整个操作系统的实现细节。xv6 保留了 Unix V6 的许多关键特性和接口，可以在现代硬件上实践 Unix 操作系统的基本概念。 通过 xv6 可以深入了解操作系统的各个方面，包括进程管理、内存管理、文件系统和设备驱动程序等。6.S081 通过实践修改和扩展XV6的代码，加深对操作系统原理和实现的理解。 进程调度 进程 PCB lock：一个自旋锁，保护进程的 p-&gt;state, p-&gt;chan, p-&gt;killed, p-&gt;xstate, p-&gt;pid 等 chan: 如果非零，则该进程在该 chan 上 sleep pagetable：该进程的用户页表 trapframe：该进程的 trapframe context：该进程的进程上下文 state：进程当前状态 UNUSED, USED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE 123456789101112131415161718192021222324// kernel/proc.hstruct proc { struct spinlock lock; // p-&gt;lock must be held when using these: enum procstate state; // Process state void *chan; // If non-zero, sleeping on chan int killed; // If non-zero, have been killed int xstate; // Exit status to be returned to parent's wait int pid; // Process ID // wait_lock must be held when using this: struct proc *parent; // Parent process // these are private to the process, so p-&gt;lock need not be held. uint64 kstack; // Virtual address of kernel stack uint64 sz; // Size of process memory (bytes) pagetable_t pagetable; // User page table struct trapframe *trapframe; // data page for trampoline.S struct context context; // swtch() here to run process struct file *ofile[NOFILE]; // Open files struct inode *cwd; // Current directory char name[16]; // Process name (debugging)}; 进程调度 进程调度过程：首先从用户态进程时钟中断转到内核调度进程，再通过内核调度进程找到一个就绪状态的进程，再调度到这个进程。 每一个进程在被创建时（kernel/proc.c中的allocproc()），都会将他的 ra 指向 forkret 这个函数，作为进程最开始的一个运行位置。（scheduler 会通过遍历进程表来找到这个标记为就绪的进程来将程序从 ra 处运行起来） 123456// kernel/proc.c// Set up new context to start executing at forkret,// which returns to user space.memset(&amp;p-&gt;context, 0, sizeof(p-&gt;context));p-&gt;context.ra = (uint64)forkret;p-&gt;context.sp = p-&gt;kstack + PGSIZE; xv6 main 函数初始化完之后进程变为调度进程运行 scheduler() 函数。 1234567// kernel/main.cvoidmain(){ ... scheduler();} kernel/proc.c 中的 scheduler() 是一个无穷循环，它每次遍历进程表 proc[]，对每一个进程尝试加锁，然后如果找到一个进程是就绪状态的，就将其设置为运行状态，然后将当前 CPU 的进程修改为这个进程，然后使用 swtch 切换上下文。调用 swtch 之后会修改 ra 的值，并且 swtch 切换上下文会保留 ra 的值，所以当内核调度进程被切换回来之后，可以回到调用 swtch 的下一句运行。同样的，内核调度进程 swtch 后会转到用户程序的 ra 进行运行，即用户程序上次调用 swtch 的下一句，如果该进程还没有被运行过，那么因为我们在创建进程的时候指定了进程的 ra 为 forkret 这个函数，那么程序首次运行就会进入 forkret 运行。 forkret 函数首先将 scheduler() 里拿到的锁释放掉，然后调用 usertrapret() 回到用户态。（此时因为 fork 进程的时候处于内核态，所以要回到用户态去）。 CPU 会定时发起时钟中断，陷入 Trap，如果一个 Trap 处理函数识别到当前中断是一个时钟中断，那么这个进程将会调用 yield() 函数放弃当前 CPU 的使用权。 yield() 先拿到进程的锁，然后调用 sched() 之后调用 swtch 切换上下文。 这里在 yield() 拿到的锁实际上是在 scheduler() 里面释放的，同样 scheduler() 拿的锁是在 yield() 中释放的。 内存管理 内存布局 物理内存布局 xv6 初始化后物理内存的布局如下图所示。 xv6 内核代码段和数据段被 loader 加载到主存开始的 1MB 到 4MB 空间内。 xv6 BIOS 储存的相关信息储存在主存开始的 0MB 到 1MB 空间内。 xv6 主存开始的 4MB 到 224MB 可以自由分配，映射给内核空间或者用户空间。 xv6 中 devices 区域是其他设备引入的存储空间，仅供设备自身使用，不是主存的一部分。 用户地址空间 用户地址空间的顶部是 trampoline 的代码 （用于切换用户态和内核态，只在内核态下被调用*）。 紧接着在 trampoline 的下面是 trapframe 页。 以上两个部分在 kernel/proc.c 中的 proc_pagetable() 进行映射。 123// kernel/proc.cmappages(pagetable, TRAMPOLINE, PGSIZE,(uint64)trampoline, PTE_R | PTE_X);mappages(pagetable, TRAPFRAME, PGSIZE,(uint64)(p-&gt;trapframe), PTE_R | PTE_W); heap 页用于用户进程调用 malloc() 分配空间。 text 与 data 段存储可执行文件，在 kernel/exec.c 中的 exec() 将指定程序的代码加载进内存，用户地址空间的最底开始。 1234567891011121314151617181920212223242526272829// kernel/exec.c// Check ELF header if(readi(ip, 0, (uint64)&amp;elf, 0, sizeof(elf)) != sizeof(elf)) goto bad; if(elf.magic != ELF_MAGIC) goto bad; if((pagetable = proc_pagetable(p)) == 0) goto bad; // Load program into memory. for(i=0, off=elf.phoff; i&lt;elf.phnum; i++, off+=sizeof(ph)){ if(readi(ip, 0, (uint64)&amp;ph, off, sizeof(ph)) != sizeof(ph)) goto bad; if(ph.type != ELF_PROG_LOAD) continue; if(ph.memsz &lt; ph.filesz) goto bad; if(ph.vaddr + ph.memsz &lt; ph.vaddr) goto bad; uint64 sz1; if((sz1 = uvmalloc(pagetable, sz, ph.vaddr + ph.memsz)) == 0) goto bad; sz = sz1; if((ph.vaddr % PGSIZE) != 0) goto bad; if(loadseg(pagetable, ph.vaddr, ip, ph.off, ph.filesz) &lt; 0) goto bad; } 在 data 之上，有两个 page，分别是 stack 和 guard page，guard page 用于防止栈溢出对程序安全造成影响（可能修改了可执行文件的地址），在 kernel/exec.c 中的 exec() 申请这两个 page。 1234567891011// kernel/exec.c// Allocate two pages at the next page boundary. // Use the second as the user stack. sz = PGROUNDUP(sz); uint64 sz1; if((sz1 = uvmalloc(pagetable, sz, sz + 2*PGSIZE)) == 0) goto bad; sz = sz1; uvmclear(pagetable, sz-2*PGSIZE); sp = sz; stackbase = sp - PGSIZE; stack 中从高地址向地址值生长，参数排列顺序如图所示。xv6 在 kernel/exec.c 中的 exec() 进行栈的填充。（包括参数、返回值）。 内核地址空间 整个 xv6 默认整个系统只有一个 kernel page。 QEMU 的计算机包含的 RAM 从地址 KERNBASE=0x80000000 到 PHYSTOP=0x86400000。内核起点位置即为 KERNBASE=0x80000000。 内核地址空间与用户地址空间一样，在顶部也同样映射了 trampoline。 trampoline 只在内核态被调用，为什么需要在用户地址空间映射 trampoline 呢*？这里其实因为用户态和内核态并不和页表进行绑定，在 ecall 调用进入内核态之后，寄存器 satp 还没修改（在 trampoline 中修改），所以当前的页表还是用户态的页表，必须要使得两个地址空间都要有 trampoline 的映射，才能 stvec 中存入正确的地址，才能使得其跳入正确的 uservec 地址。 每个进程都在内核页表中分配了一个内核栈 kstack，用于在内核态的栈，在 kernel/proc.c 中的 proc_mapstacks() 进行分配映射。 kernel/kernel.ld 中加载内核，会指定 etext（kernel 程序代码之后的地址）的值。 kernel page 的映射在 kernel/exec.c 中的 kvmmake() 进行直接映射。 123456789101112131415161718192021222324252627282930313233// Make a direct-map page table for the kernel.pagetable_tkvmmake(void){ pagetable_t kpgtbl; kpgtbl = (pagetable_t) kalloc(); memset(kpgtbl, 0, PGSIZE); // uart registers kvmmap(kpgtbl, UART0, UART0, PGSIZE, PTE_R | PTE_W); // virtio mmio disk interface kvmmap(kpgtbl, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W); // PLIC kvmmap(kpgtbl, PLIC, PLIC, 0x400000, PTE_R | PTE_W); // map kernel text executable and read-only. kvmmap(kpgtbl, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X); // map kernel data and the physical RAM we'll make use of. kvmmap(kpgtbl, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W); // map the trampoline for trap entry/exit to // the highest virtual address in the kernel. kvmmap(kpgtbl, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X); // map kernel stacks proc_mapstacks(kpgtbl); return kpgtbl;} 内存分配 xv6 将主存（物理内存）中的空闲内存分割成 4KB 大小的页框 (page frame)，并用链表将他们组织起来成为空闲链表。 在 kernel/kalloc.c 中进行处理。 空闲内存页表的数据结构： 12345678// kernel/kalloc.cstruct run { struct run *next;}; // 表结点struct { struct spinlock lock; struct run *freelist;} kmem; // 链表 先使用 freerange()，将物理内存分割为 4KB 大小的页框： 123456789101112131415// kernel/kalloc.cvoidfreerange(void *pa_start, void *pa_end){ char *p; p = (char*)PGROUNDUP((uint64)pa_start); for(; p + PGSIZE &lt;= (char*)pa_end; p += PGSIZE) kfree(p); // kfree 相当于将该页释放并且加到空闲链表中}voidkinit(){ initlock(&amp;kmem.lock, &quot;kmem&quot;); freerange(end, (void*)PHYSTOP); // 将物理内存分割} 分配页，从空闲链表拿链表头出来进行分配： 12345678910111213141516171819// kernel/kalloc.c// Allocate one 4096-byte page of physical memory.// Returns a pointer that the kernel can use.// Returns 0 if the memory cannot be allocated.void *kalloc(void){ struct run *r; acquire(&amp;kmem.lock); r = kmem.freelist; if(r) kmem.freelist = r-&gt;next; // 从空闲链表拿链表头出来进行分配 release(&amp;kmem.lock); if(r) memset((char*)r, 5, PGSIZE); // fill with junk return (void*)r;} 释放页，并且将其放入空闲链表的头部 1234567891011121314151617181920212223// kernel/kalloc.c// Free the page of physical memory pointed at by v,// which normally should have been returned by a// call to kalloc(). (The exception is when// initializing the allocator; see kinit above.)voidkfree(void *pa){ struct run *r; if(((uint64)pa % PGSIZE) != 0 || (char*)pa &lt; end || (uint64)pa &gt;= PHYSTOP) panic(&quot;kfree&quot;); // Fill with junk to catch dangling refs. memset(pa, 1, PGSIZE); r = (struct run*)pa; acquire(&amp;kmem.lock); r-&gt;next = kmem.freelist; kmem.freelist = r; // 将其放入空闲链表的头部 release(&amp;kmem.lock); // 释放页} 页表 xv6 中只使用低 39 位的虚拟地址 (virtual address，VA)。低 56 位的物理地址 (physical address，PA)。 单级页表 VA 高 27 位用来索引页表（页表有2^27个页表项（page table entry, PTE)，每个页表项有一个 44 位的物理页编号(physical page number, PPN) 以及 10 位的 flag 位。 PA 的地址由 44 位 PPN 与 VA 低 12 位的 offset(页内偏移) 组合而成，因此 PA 地址范围为 256 三级页表 VA 高 27 位仍然用来索引页表，但是用前 9 位来索引一级页表，找到对应的 44 位 PPN，末尾补 0 后为二级页表的地址。使用 L1 索引二级页表，以此类推，找到最后的页表项，然后转化为物理地址。 xv6 在 kernel/vm.c 中的 walk() 来通过 VA 找 PA。 1234567891011121314151617181920// kernel/vm.cpte_t *walk(pagetable_t pagetable, uint64 va, int alloc){ if(va &gt;= MAXVA) panic(&quot;walk&quot;); for(int level = 2; level &gt; 0; level--) { pte_t *pte = &amp;pagetable[PX(level, va)]; if(*pte &amp; PTE_V) { pagetable = (pagetable_t)PTE2PA(*pte); } else { if(!alloc || (pagetable = (pde_t*)kalloc()) == 0) return 0; memset(pagetable, 0, PGSIZE); *pte = PA2PTE(pagetable) | PTE_V; } } return &amp;pagetable[PX(0, va)];} 指令详解 exec exec() 会将存在文件系统内的程序放入内存并执行。 xv6 在 kernel/exec.c 中的 exec() 实现。 一个 ELF 包含 ELF 头 (struct elfhdr)，程序部分头 (struct proghdr)，每一个 proghdr 包含需要被加载进内存的程序信息。 然后分配两个页在 ELF 之上，用来当做栈以及 guard page。 然后将程序的参数压入栈中，分配 argc 个位置，然后再分配 argc 个位置，存对应参数的指针，然后将寄存器 a0 放入 argc，寄存器 a1 放入 argv 的指针，initcode.S 将参数放进 exec() 的 a0 和 a1 寄存器，并且将系统调用号放入寄存器 a7。 fork fork() 将运行着的程序分成两个几乎一样的进程。 xv6 在 kernel/proc.c 中的 fork() 实现。 先分配一个新的进程 12345// kernel/proc.c// Allocate process.if((np = allocproc()) == 0){ return -1;} 然后将页表复制，寄存器复制，设置子进程返回值为 0 1234567891011121314// kernel/proc.c// Copy user memory from parent to child.if(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; 0){ freeproc(np); release(&amp;np-&gt;lock); return -1;}np-&gt;sz = p-&gt;sz;// copy saved user registers.*(np-&gt;trapframe) = *(p-&gt;trapframe);// Cause fork to return 0 in the child.np-&gt;trapframe-&gt;a0 = 0; 将父进程打开的 fd 进行引用数加一，并且父进程返回子进程的 pid 12345678910// kernel/proc.c// increment reference counts on open file descriptors.for(i = 0; i &lt; NOFILE; i++) if(p-&gt;ofile[i]) np-&gt;ofile[i] = filedup(p-&gt;ofile[i]);np-&gt;cwd = idup(p-&gt;cwd);...return pid; Copy on Write (CoW) 系统调用 trap system call: 系统调用，用户程序调用 ecall 发生 trap exception: 异常，用户态或者内核态触发异常（如除 0 异常或者页地址错误） interrupt：中断，硬件设备通过信号进行中断，或者时钟中断 trap 都在内核态完成处理 trap 寄存器 stvec: 内核将 trap 处理函数（uservec 或 kernelvec）地址放在这里，方便 RISC-V 跳转到处理函数处理 trap sepc: trap 发生后，RISC-V 将 pc 保存到这里，在从 trap 中返回时 sret 将会把 sepc 复制回 pc scause: trap 的类型数 sscratch: sstatus: 其中的 SIE 位控制中断是否开启，SPP 位标识 trap 是从用户态还是内核态来的 用户态发生 Trap 流程：ecall -&gt; uservec (kernel/trampoline.S) -&gt; usertrap (kernel/trap.c) -&gt; usertrapret (kernel/trap.c) -&gt; userret (kernel/trampoline.S) 发生 Trap 时，调用 ecall 后会关闭中断，以防重复中断进入 Trap 处理函数。 然后 xv6 读取 stval 的值并且跳转到其对应的地址（若在用户态，则跳转到 uservec，若在内核态，则跳转到 kernelvec） 在 uservec 中，首先使用 csrw 将 a0 寄存器和 sscratch 寄存器的值进行交换，使得 a0 中存的是 trapframe 的地址，接下来就可以使用 a0 来寻址 trapframe。然后将 32 个寄存器保存在 trapframe 中，将内核栈指针、内核 hartid、usertrap 地址加载到寄存器中，并且将页表切换到内核页表（修改 satp)，然后跳转到 usertrap()。 在 usertrap() 中，首先判断是否是从用户态来的 Trap（判断 SPP 位），然后因为当前已经在内核态，如果再发生中断 (系统调用里可能会再次中断)，则转入内核处理函数，所以要将 stvec 修改位内核处理函数。然后将用户的 pc 保存到 epc，判断中断原因，如果是系统调用则开启中断，进入 syscall()。 然后将会调用 usertrapret 返回用户态，关闭中断，将 stvec 复原到用户态的处理函数，还原，还原 pc，然后执行 userret。 userret 中将页表切换（修改 satp），将 32 个寄存器还原，然后 sret。 内核态发生 Trap kernelvec 中将寄存器保存在栈中，然后使用 call kerneltrap 调用 kerneltrap()，调用完后回到 kerneltrap()，恢复寄存器的值。 在 kerneltrap() 中，先判断是否从内核态来的 Trap，然后检查是否关闭中断防止重入，然后判断中断类型进行操作。此函数执行完后会回到 kernelvec。 系统调用过程 进入中断，寄存器 a7 存入系统调用号，a0 存系统调用的返回值。syscall 通过一个映射表找到对应的 syscall。 12345678910111213141516// kernel/syscall.cvoidsyscall(void){ int num; struct proc *p = myproc(); num = p-&gt;trapframe-&gt;a7; if(num &gt; 0 &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) { p-&gt;trapframe-&gt;a0 = syscalls[num](); } else { printf(&quot;%d %s: unknown sys call %d\\n&quot;, p-&gt;pid, p-&gt;name, num); p-&gt;trapframe-&gt;a0 = -1; }} 系统调用参数存在 a0、a1、a2、a3、a4、a5，使用 argraw() 函数进行获取。 12345678910111213141516171819202122// kernel/syscall.cstatic uint64argraw(int n){ struct proc *p = myproc(); switch (n) { case 0: return p-&gt;trapframe-&gt;a0; case 1: return p-&gt;trapframe-&gt;a1; case 2: return p-&gt;trapframe-&gt;a2; case 3: return p-&gt;trapframe-&gt;a3; case 4: return p-&gt;trapframe-&gt;a4; case 5: return p-&gt;trapframe-&gt;a5; } panic(&quot;argraw&quot;); return -1;} 文件系统 文件系统结构 Block 0：包含 boot sector Block 1：称为 superblock (包含文件系统的信息，Block 数量、Inode 数量、在 log 内的 Block 数)，被 mkfs 初始化 Block 2 开始：log block inodes bitmap：记录哪个 data block 是在被使用的 data：data block，数据块 inode inode 有两层含义 硬盘上的 inode，包含文件的大小和数据块编号 内存中的 inode 硬盘 inode 在硬盘一个连续的区域 inode 块存储。每个 inode 是固定的 1024 字节。因此我们可以通过 inode 号找到指定编号的 inode。 1234567891011121314// kernel/fs.h#define BSIZE 1024 // block size#define NDIRECT 12#define NINDIRECT (BSIZE / sizeof(uint))#define MAXFILE (NDIRECT + NINDIRECT)// On-disk inode structurestruct dinode { short type; // File type short major; // Major device number (T_DEVICE only) short minor; // Minor device number (T_DEVICE only) short nlink; // Number of links to inode in file system uint size; // Size of file (bytes) uint addrs[NDIRECT+1]; // Data block addresses}; 所有内存中活动的 inode 都存进 itable 中。 12345// kernel/fs.cstruct { struct spinlock lock; struct inode inode[NINODE];} itable; 只有有对该 inode 的引用才将其载入内存。 12345678910111213141516// kernel/file.h// in-memory copy of an inodestruct inode { uint dev; // Device number uint inum; // Inode number int ref; // Reference count struct sleeplock lock; // protects everything below here int valid; // inode has been read from disk? short type; // copy of disk inode short major; short minor; short nlink; uint size; uint addrs[NDIRECT+1];}; ref 字段用来标识该 inode 被引用了几次。iget() 和 iput() 获取和释放 inode 的一个引用。对 inode 的引用来自 fd、当前工作目录以及 exec()。 iget() 和 iput() 在 kernel/fs.c 中。 nlink 字段用来标识有多少个目录项引用该文件。 ialloc() 分配一个 inode inode 内容 开始 NDIRECT=12 个 block 直接放在 dinode 中的 addr[] 称为 direct blocks，之后 NINDIRECT 个 block 不放在 dinode 中而是放在 data block 中称为 indirect blocks，这些 block 的索引存在 addr[] 最后一个 block 中。 inode 结构 bmap() 找到 inode 中的第 n 个块，没有则分配。 readi() 和 writei() 分别可以读取和写 inode 的内容。","link":"/xv6/"}],"tags":[{"name":"Loj","slug":"Loj","link":"/tags/Loj/"},{"name":"Trie","slug":"Trie","link":"/tags/Trie/"},{"name":"杂言","slug":"杂言","link":"/tags/%E6%9D%82%E8%A8%80/"},{"name":"xv6","slug":"xv6","link":"/tags/xv6/"},{"name":"操作系统","slug":"操作系统","link":"/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"categories":[{"name":"Loj","slug":"Loj","link":"/categories/Loj/"},{"name":"Default","slug":"Default","link":"/categories/Default/"}],"pages":[{"title":"","text":"FlyInTheSky，广东深圳某本科计算机科学与技术专业在读。 后端开发，地理、地图、城市、公交地铁爱好者 C++ / Go 欢迎交流。","link":"/about/index.html"},{"title":"","text":"友情链接 .friend-link { display: flex; align-items: center; margin-bottom: 20px; background-color: #f8f8f8; padding: 10px; border-radius: 5px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); } .friend-avatar { width: 60px; height: 60px; border-radius: 50%; margin-right: 15px; border: 2px solid #fff; box-shadow: 0 0 0 4px #f8f8f8; } .friend-name { font-weight: bold; font-size: 16px; color: #333; } .friend-intro { font-size: 14px; color: #666; } .friend-website-url { color: #007bff; text-decoration: none; transition: color 0.3s ease; } .friend-website-url:hover { color: #0056b3; } Me 曾经高中 OI 时期的博客存档，想要看算法题解的可以去看看~ https://oi.lyffly.com/ InverseDa 腾讯光子游戏开发爷，精通图形学，达达人超好！ https://blog.inverseda.top/ Tabing 腾讯 TEG 前端实习大佬，浇浇我前端 https://abinea.top/ 正汰 字节抖音实习大佬，信安 Web 选手，电协前会长 https://blog.hz2016.com/ Some 干穿 rcore，未来的 Rust 大佬 https://somewan820.github.io/","link":"/friends/index.html"}]}